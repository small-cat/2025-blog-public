在 C 中，数组名通常被用作指向数组首元素的指针。比如声明一个数组时，
```
int arr[10];
```
arr 表示一个包含 10 个 int 类型元素的数组。在大多数情况下，arr 被解释为一个指向数组首地址的的指针，即 arr 等同于 &arr[0]。

实际上，数组名并不是一个可以修改的指针变量，而是一个表示整个数组的标识符。在表达式中使用数组名时，它通常会被解释为一个指向数组第一个元素的指针常量（类型为指向元素类型的指针），但这种转换并不适用于所有情况。

与普通指针变量不同的是，数组名代表的内存地址是不可变的。比如
```
int arr[10];
int *ptr = arr; // 正确：ptr 现在指向 arr 的第一个元素
ptr++;          // 正确：移动 ptr 到下一个整数位置
arr++;          // 错误：arr 表示指向数组的指针常量，不能修改，可以理解成 int * const arr
```

另外，数组名在某些特定的上下文中并不会转换为指针，例如：
同时，数组名在某些情况下并不会转换为指针，比如：
- sizeof 运算符：sizeof(arr)将返回整个数组的大小，而不是指针的大小。sizeof(arr) = 10 * sizeof(int)，即数组所占用的总字节数。
- 取地址运算符：&arr 返回指向整个数组的指针，其类型是指向包含 10 个 int 的数组的指针，即 int (*)[10]。
在这两种情况下，数组名代表整个数组，而不是单纯的指向第一个元素的指针。

而当数组名出现在函数参数中时，通常被当做成指针进行处理，比如
```
int Sum(int arr[]) {
  ...
}

int total = Sum(arr);
``` 
这个时候，在 Sum 函数的定义中，既可以通过指针的形式访问数组，也可以通过数组的形式访问数组。

当然，从编译器的角度来说，当我们使用数组名和 [] 的形式访问数组元素时，编译器会将这种访问形式 resolve 成指针操作的形式，比如
```
arr[5] -> *(arr + 5)
```
那当然也可以写成
```
*(5 + arr) -> 5[arr]
```
也就是说，arr[5] 和 5[arr] 这两种写法都是等价，且都是正确的，只不过后面那种写法就显得很奇怪，通常没人会这样写。但是对编译器来说，这两者并没什么区别。